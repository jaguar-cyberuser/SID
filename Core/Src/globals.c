/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    globals.c
  * @brief   Реализация глобальных функций времени на аппаратных таймерах
  ******************************************************************************
  * TIM4 используется как единственный системный таймер с периодом 1ms.
  * Все временные функции построены на основе этого таймера.
  * ДОБАВЛЕНЫ ВСЕ ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ДЛЯ СИСТЕМЫ ДОСТУПА
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "globals.h"
/* USER CODE BEGIN Includes */
#include "common_defines.h"  // Добавлено для констант доступа
#include "modbus.h"          // Добавлено для MODBUS_REG_COUNT
/* USER CODE END Includes */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/**
  * @brief Счетчик системного времени (обновляется в TIM4)
  * @note  Заменяет uwTick из HAL, обеспечивает независимое системное время
  *        Инкрементируется в прерывании TIM4 каждую 1ms
  */
volatile uint32_t system_ticks = 0;

/**
  * @brief Время последнего принятого символа Modbus
  * @note Обновляется в прерывании UART при каждом принятом символе
  *       Используется для детектирования активности на линии RS-485
  */
uint32_t modbus_last_rx_time = 0;

/**
  * @brief Текущий уровень доступа к системе
  * @note Инициализируется уровнем 0 (только чтение) при старте
  *       Может быть изменен через регистр 5 с паролем
  */
volatile uint8_t current_access_level = ACCESS_LEVEL_0;

/**
  * @brief Флаги изменений конфигурации
  * @note Используются для автоматической записи в Flash при изменениях
  */
bool config_modified = false;
bool calib_modified = false;

/**
  * @brief Буфер предыдущих значений регистров
  * @note Используется для обнаружения изменений в регистрах
  */
uint16_t previous_registers[MODBUS_REG_COUNT] = {0};

/* USER CODE END PV */

/* Function implementations --------------------------------------------------*/
/* USER CODE BEGIN 0 */

// Переопределение слабой функции HAL_GetTick
__weak uint32_t HAL_GetTick(void)
{
    return GET_TICKS();
}

/**
  * @brief  Получение текущего системного времени
  * @retval Текущее время в миллисекундах
  * @note   Атомарное чтение глобальной переменной с запретом прерываний
  *         Гарантирует целостность данных при чтении из разных контекстов
  */
uint32_t GET_TICKS(void)
{
    uint32_t ticks;
    
    /* Критическая секция - запрещаем прерывания на время чтения */
    __disable_irq();
    ticks = system_ticks;
    __enable_irq();
    
    return ticks;
}

/**
  * @brief  Проверка истекшего времени
  * @param  timestamp: Временная метка для проверки
  * @param  delay_ms: Время задержки в миллисекундах
  * @retval true - время истекло, false - время не истекло
  * @note   Корректно обрабатывает переполнение счетчика (каждые ~49 дней)
  *         Используется для неблокирующих задержек и таймаутов
  */
bool TICKS_ELAPSED(uint32_t timestamp, uint32_t delay_ms)
{
    uint32_t current_ticks = GET_TICKS();
    
    /* Обработка переполнения uint32_t */
    if (current_ticks < timestamp)
    {
        /* Переполнение счетчика - вычисляем разницу с учетом цикла */
        return ((0xFFFFFFFFU - timestamp + current_ticks) >= delay_ms);
    }
    else
    {
        /* Нормальный случай без переполнения */
        return ((current_ticks - timestamp) >= delay_ms);
    }
}

/**
  * @brief  Блокирующая задержка на основе аппаратного таймера
  * @param  delay_ms: Задержка в миллисекундах
  * @retval None
  * @note   Использует активное ожидание на системном времени TIM4
  *         Прерывания продолжают работать во время задержки
  */
void HARDWARE_DELAY(uint32_t delay_ms)
{
    uint32_t start_time = GET_TICKS();
    
    // Активное ожидание с разрешенными прерываниями
    while (!TICKS_ELAPSED(start_time, delay_ms))
    {
        // Дополнительная оптимизация энергопотребления
        __WFI(); // Wait For Interrupt - снижение потребления
    }
}

/* USER CODE END 0 */
